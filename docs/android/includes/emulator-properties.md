|プロパティ|説明|オプション|
|--- |--- |--- |
|`abi.type`|**ABI の型**&ndash;エミュレートされたデバイスの ABI (アプリケーション バイナリ インターフェイス) の種類を指定します。 **X86**オプションは、命令セットの別名、"x86"または"ia-32"用、 **X86_64**オプションは、64 ビット x86 命令セット。 **Armeabi v7a**オプションは、ARM 命令を v7、ARM の拡張子を持つセット用です。 **Arm64 v8a**オプションは、AArch64 をサポートする ARM 命令セット用です。|x86、x86_64、armeabi-v7a、arm64-v8a|
|`disk.cachePartition`|**キャッシュ パーティション**&ndash;エミュレートされたデバイスを使用するかどうかを決定する **/cache**デバイス上のパーティション。 **/Cache** (これは最初は空) のパーティションは、Android が頻繁にアクセスされるデータとアプリ コンポーネントを格納する場所。 場合に設定**ありません**、エミュレーターは使用しない、 **/cache**パーティションを`disk.cache`設定は無視されます。|yes、no|
|`disk.cachePartition.path`|**キャッシュ パーティション パス**&ndash;開発用コンピューターにキャッシュ パーティション イメージ ファイルを指定します。 エミュレーターが、このファイルを使用して、 **/cache**パーティション。 エミュレーターのデータ ディレクトリの相対パスまたは絶対パスを入力します。 かどうか設定されていない、エミュレーター作成という空の一時ファイル**cache.img**開発用コンピューターにします。 ファイルが存在しない場合は、空のファイルとして作成されます。 場合、このオプションは無視されます`disk.cachePartition`に設定されている**ありません**します。||
|`disk.cachePartition.size`|**キャッシュ パーティション サイズ**&ndash;バイト単位でキャッシュ パーティション ファイルのサイズ。 通常は、既定のキャッシュ サイズである 66 メガバイトを超える非常に大きなファイルをアプリがダウンロードする場合を除き、このオプションを設定する必要はありません。 場合、このオプションは無視されます`disk.cachePartition`に設定されている**ありません**します。 この値が整数である場合は、バイト単位でサイズを指定します。 追加することによって、キロバイト、メガバイト、ギガバイト単位でサイズを指定することも**K**、 **M**、または**G**値にします。 最小サイズは**9 分**と最大サイズが**1023 G**します。||
|`disk.dataPartition.initPath`|**データ パーティションへの最初のパス**&ndash;データ パーティションの初期コンテンツを指定します。 ユーザー データをワイプした後は、エミュレーターはユーザー データを指定したファイルの内容をコピー (既定では、 **userdata qemu.img**) を使用してではなく**userdata.img**として初期のバージョン。||
|`disk.dataPartition.path`|**データ パーティションへのパス**&ndash;ユーザー データのパーティション ファイルを指定します。 永続的なユーザー データ ファイルを構成するには、開発コンピューターでファイル名とパスを入力します。 エミュレーターが既定のファイルからイメージを作成、ファイルが存在しない場合**userdata.img**、によって指定されたファイル名に格納`disk.dataPartition.path`エミュレーターのシャット ダウン時にユーザー データを保持します。 既定のファイルの名前は、パスを指定しない場合**userdata qemu.img**します。 特殊な値**<temp>** を作成し、一時ファイルを使用してエミュレーターをによりします。 場合`disk.dataPartition.initPath`設定された場合、そのコンテンツにコピーされますが、`disk.dataPartition.path`ブート時にファイル。 このオプションを空白のままにすることはできないことに注意してください。||
|`disk.dataPartition.size`|**データ パーティション サイズ**&ndash;バイトで、ユーザー データ パーティションのサイズを指定します。 この値が整数である場合は、バイト単位でサイズを指定します。 追加することによって、キロバイト、メガバイト、ギガバイト単位でサイズを指定することも**K**、 **M**、または**G**値にします。 最小サイズは**9 分**と最大サイズが**1023 G**します。||
|`disk.ramdisk.path`|**Ramdisk パス**&ndash;ブート パーティション (ramdisk) イメージへのパス。 ramdisk イメージは、システム イメージがマウントされる前にカーネルによって読み込まれるシステム イメージのサブセットです。 通常、ramdisk イメージには、起動時のバイナリと初期化スクリプトが含まれます。 このオプションが指定されていない場合、既定値は**ramdisk.img**エミュレーターのシステム ディレクトリ。||
|`disk.snapStorage.path`|**スナップショット記憶域パス**&ndash;のすべてのスナップショットの格納場所、スナップショット ストレージ ファイルへのパス。 実行中に作成されたスナップショットはすべてこのファイルに保存されます。 エミュレーターの実行中に復元できるのは、このファイルに保存されているスナップショットのみです。 このオプションが指定されていない場合、既定値はエミュレーターのデータ ディレクトリ snapshots.img は。||
|`disk.systemPartition.initPath`|**システム パーティションの init パス**&ndash;システムのイメージ ファイルの読み取り専用コピーへのパス。 具体的には、システム ライブラリと API レベルおよびすべてのバリアントに対応するデータが含まれるパーティション。 このパスが指定されていない場合は、既定では system.img エミュレーターのシステム ディレクトリです。||
|`disk.systemPartition.path`|**システム パーティション パス**&ndash;読み取り/書き込みのシステム パーティション イメージへのパス。 このパスが設定されていない場合、一時ファイルが作成されで指定されたファイルの内容から初期化`disk.systemPartition.initPath`します。||
|`disk.systemPartition.size`|**システムのパーティション サイズ** &ndash; (バイト単位) で、システム パーティションの最適なサイズ。 実際のシステム パーティション イメージがこの設定よりも大きい場合、サイズは無視されます。それ以外の場合は、システム パーティション ファイルを拡大できる最大サイズが指定されます。 この値が整数である場合は、バイト単位でサイズを指定します。 追加することによって、キロバイト、メガバイト、ギガバイト単位でサイズを指定することも**K**、 **M**、または**G**値にします。 最小サイズは**9 分**と最大サイズが**1023 G**します。||
|`hw.accelerometer`|**加速度計**&ndash;エミュレートされたデバイスに、加速度計センサーが含まれるかどうかを判断します。 加速度計は、デバイスが (自動回転で使用される) 向きを判別するのに役立ちます。 加速度計は、3 つのセンサー軸に沿ってデバイスのアクセラレーションを報告します。|yes、no|
|`hw.audioInput`|**オーディオ録音サポート**&ndash;エミュレートされたデバイスでオーディオを録音できるかどうかを決定します。|yes、no|
|`hw.audioOutput`|**オーディオ再生サポート**&ndash;オーディオ エミュレートされたデバイスを再生できるかどうかを決定します。|yes、no|
|`hw.battery`|**バッテリ サポート**&ndash;エミュレートされたデバイスがバッテリで実行できるかどうかを決定します。|yes、no|
|`hw.camera`|**カメラ サポート**&ndash;エミュレートされたデバイスにカメラがあるかどうかを決定します。|yes、no|
|`hw.camera.back`|**背面カメラ**&ndash;背面カメラ (レンズ面ユーザーから離れる) を構成します。 Web カメラにこの値を設定する必要がありますエミュレートされたデバイスの背面カメラをシミュレートするために、開発用コンピューターに web カメラを使用する場合*n*ここで、 _n_ (1 つだけの web カメラがある場合は、web カメラを選択します選択**webcam0**)。 設定がエミュレートされる場合、エミュレーターはソフトウェアでカメラをシミュレートします。 背面カメラを無効にするには、場合は、この値を none に設定します。 背面カメラを有効にした場合にも有効にすることを確認して`hw.camera`します。|emulated、none、webcam0|
|`hw.camera.front`|**前面カメラ**&ndash;前面カメラ (レンズ面がユーザーの方) を構成します。 Web カメラにこの値を設定する必要がありますエミュレートされたデバイスの前面カメラをシミュレートするために、開発用コンピューターに web カメラを使用する場合*n*ここで、 _n_ (1 つだけの web カメラがある場合は、web カメラを選択します、選択**webcam0**)。 設定がエミュレートされる場合、エミュレーターはソフトウェアでカメラをシミュレートします。 前面カメラを無効にするには、場合は、この値を none に設定します。 前面カメラを有効にした場合にも有効にすることを確認して`hw.camera`します。|emulated、none、webcam0|
|`hw.camera.maxHorizontalPixels`|**カメラの水平方向の最大ピクセル** &ndash; (ピクセル単位) でエミュレートされたデバイスのカメラの最大水平方向の解像度を構成します。||
|`hw.camera.maxVerticalPixels`|**カメラの垂直方向の最大ピクセル**&ndash;最大垂直方向の解像度 (ピクセル単位)、エミュレートされたデバイスのカメラを構成します。||
|`hw.cpu.arch`|**CPU アーキテクチャ**&ndash;仮想デバイスでエミュレートされる CPU アーキテクチャ。 Intel HAXM ハードウェア アクセラレータを使用している場合は、選択**x86** 32 ビットの CPU に対応します。 選択**x86_64**の 64 ビットの HAXM アクセラレーション デバイス。 (SDK Manager での対応する Intel x86 システム イメージをインストールしてくださいたとえば、Intel x86 Atom または Intel x86 Atom_64。)。ARM CPU をシミュレートするには、次のように選択します。 **arm**の 32 ビットまたは select **arm64** 64 ビットの ARM cpu。 ARM ではハードウェア アクセラレータを使用できないため、ARM ベースの仮想デバイスは x86 ベースのものよりかなり遅く実行されることに留意してください。|x86、x86_64、arm、arm64|
|`hw.cpu.model`|**CPU モデル**&ndash;この値が設定されていないまま通常 (から派生した値に設定されます`hw.cpu.arch`明示的に設定されていない場合)。 ただし、実験用にエミュレーター固有の文字列に設定することはできます。||
|`hw.dPad`|**DPad キー** &ndash;エミュレートされたデバイスが方向パッド (DPad) キーをサポートするかどうかを決定します。 通常、DPad には方向制御を示す 4 つのキーがあります。|yes、no|
|`hw.gps`|**GPS サポート**&ndash;エミュレートされたデバイスに GPS (Global Positioning System) 受信機があるかどうかを決定します。|yes、no|
|`hw.gpu.enabled`|**GPU エミュレーション**&ndash;エミュレートされたデバイスが GPU エミュレーションをサポートするかどうかを決定します。 有効な場合、GPU エミュレーションでは、画面上で 2D と 3D の両方のグラフィックをレンダリングするために OpenGL ES (Open GL for Embedded Systems) を使用し、関連付けられている GPU エミュレーション モード設定で GPU エミュレーションの実装方法を決定します。|yes、no|
|`hw.gpu.mode`|**GPU エミュレーション モード**&ndash;エミュレーターで GPU エミュレーションを実装する方法を決定します。 自動選択すると、エミュレーターは、開発コンピューターの設定に基づいて、ハードウェアとソフトウェアのアクセラレータを選択します。 ホストを選択した場合、エミュレーターはレンダリングを高速の GPU エミュレーションを実行する開発用コンピューターのグラフィック プロセッサを使用します。 ご使用の GPU がエミュレーターと互換性がありませんし、Windows を使用している場合は、ホストではなく角度を試行できます。 角度のモードでは、DirectX を使用して、ホストと同様のパフォーマンスを提供します。 Mesa を選択した場合、エミュレーターは Mesa 3D ソフトウェア ライブラリ グラフィックスを表示するために使用します。 開発用コンピューターのグラフィック プロセッサを使用してレンダリングの問題がある場合は、mesa を選択します。 Swiftshader モードは、ソフトウェア、コンピューターの GPU を使用するよりもパフォーマンスが若干低いでグラフィックを表示するために使用できます。 Off オプション (グラフィック ハードウェア エミュレーションを無効にする) は、いくつかの不適切なレンダリングを引き起こす可能性のあるオプションを非推奨の項目し、は推奨されません。|auto、host、mesa、angle、swiftshader、off|
|`hw.gsmModem`|**GSM モデム サポート**&ndash;エミュレートされたデバイスが、GSM (Global System for Mobile Communications) テレフォニー ラジオ システムをサポートするモデムを含めるかどうかを指定します。|yes、no|
|`hw.initialOrientation`|**最初の画面の向き**&ndash;エミュレートされたデバイス (縦または横モード) で、画面の最初の向きを構成します。 縦モードの場合、画面は縦長になります。 横モードの場合、画面は横長になります。 エミュレートされたデバイスを実行するときに、デバイス プロファイルで縦と横の両方がサポートされている場合は、向きを変更できます。|portrait、landscape|
|`hw.keyboard`|**キーボード サポート**&ndash;エミュレートされたデバイスが QWERTY キーボードをサポートするかどうかを決定します。|yes、no|
|`hw.keyboard.charmap`|**キーボード charmap 名**&ndash;このデバイスのハードウェア charmap の名前。 注: これは常に既定の**qwerty2**システム イメージを適宜変更している場合を除き、します。 この名前は起動時にカーネルに送信されます。 正しくない名前を使用すると、仮想デバイスが使用できなくなります。||
|`hw.keyboard.lid`|**キーボードのサポート**&ndash;かどうか、QWERTY キーボード閉じる/非表示にできるか、開く/表示できるキーボードのサポートが有効になっている場合は、この設定を決定します。 Hw.keyboard が false に設定されている場合、この設定は無視されます。 注: 既定値は、エミュレートされたデバイス API レベル 12 以上を対象とする場合は false です。|yes、no|
|`hw.lcd.backlight`|**LCD バックライト**&ndash;エミュレートされたデバイスで LCD バックライトがシミュレートされるかどうかを決定します。|yes、no|
|`hw.lcd.density`|**LCD の密度**&ndash;単位密度に依存しないピクセル単位または dp、エミュレートされた LCD ディスプレイの密度 (dp は仮想ピクセル単位)。 設定が 160 dp の場合、各 dp は 1 物理ピクセルに対応します。 実行時に、Android はこの値を使用して、正しいディスプレイ レンダリングに適切なリソース/アセットを選択してスケーリングします。|120、160、240、213、320|
|`hw.lcd.depth`|**LCD の色深度** &ndash; LCD ディスプレイを駆動のビットマップを保持する、エミュレートされたフレームバッファの色ビット深度。 この値には 16 ビット (65,536 色表示可能) または 32 ビット (16,777,216 色と透明) を指定できます。 32 ビットを設定すると、エミュレーターの実行速度が若干低下しますが、色の精度が向上します。|16, 32|
|`hw.lcd.height`|**LCD のピクセルの高さ**&ndash;エミュレートされた LCD ディスプレイの垂直ディメンションを構成するピクセル数。||
|`hw.lcd.width`|**LCD のピクセル幅**&ndash;エミュレートされた LCD ディスプレイの水平ディメンションを構成するピクセル数。||
|`hw.mainKeys`|**ハードウェアの Back/home キー** &ndash;エミュレートされたデバイスがハードウェアの Back をサポートするかどうか、および Home ナビゲーション ボタンを判断します。 この値を設定することができます**はい**ボタンがソフトウェアでのみ実装されている場合。 場合`hw.mainKeys`に設定されている**はい**エミュレーターでは、画面上のナビゲーション ボタンは表示されませんが、エミュレーター側のパネルを使用してこれらのボタンを「押す」ことができます。|yes、no|
|`hw.ramSize`|**デバイスの RAM サイズ**&ndash;メガバイト単位で、エミュレートされたデバイス上の物理 RAM の容量。 既定値は、画面のサイズまたはスキン バージョンから計算されます。 サイズを増やすことでエミュレーターの操作速度を上げることはできますが、その代わり、開発コンピューターからのリソース要求が増えます。||
|`hw.screen`|**タッチ スクリーンの種類**&ndash;エミュレートされたデバイスの画面の種類を定義します。 マルチタッチ画面は、タッチ インターフェイスで 2 つ以上の指を追跡できます。 タッチ スクリーンでは、1 本指によるタッチ イベントのみを検出できます。 No タッチ スクリーンでは、タッチ イベントは検出されません。|touch、multi-touch、no-touch|
|`hw.sdCard`|**SDCard サポート**&ndash;エミュレートされたデバイスが仮想 SD (セキュア デジタル) カードの挿入と削除をサポートするかどうかを決定します。 エミュレーターでは、開発用コンピューターに格納されているマウント可能ディスク イメージを使用して、実際の SD カード デバイス (hw.sdCard.path を参照してください) のパーティションをシミュレートします。|yes、no|
|`sdcard.size`|**SDCard サイズ**&ndash;によって指定された場所に仮想 SD カード ファイルのサイズを示す`hw.sdCard.path`します。 バイト単位でのデバイスで使用できます。 この値が整数である場合は、バイト単位でサイズを指定します。 追加することによって、キロバイト、メガバイト、ギガバイト単位でサイズを指定することも**K**、 **M**、または**G**値にします。 最小サイズは**9 分**と最大サイズが**1023 G**します。||
|`hw.sdCard.path`|**SDCard イメージ パス**&ndash;開発用コンピューターで SD カード パーティション イメージ ファイルへのパスとファイル名を指定します。 たとえば、このパスに設定する可能性があります**C:\sd\sdcard.img** Windows にします。||
|`hw.sensors.magnetic_field`|**磁場センサー** &ndash;エミュレートされたデバイスが磁場センサーをサポートするかどうかを決定します。 磁場センサー (磁力計ともいう) は、3 つのセンサー軸に沿って測定されたアンビエント磁場を報告します。 コンパス読み取り値へのアクセスが必要なアプリに対して、この設定を有効にします。 たとえば、ナビゲーション アプリではこの設定を使用して、ユーザーがどの方向を向いているかを検出する場合があります。|yes、no|
|`hw.sensors.orientation`|**方向センサー** &ndash;エミュレートされたデバイスがセンサーの値についての向きを提供しているかどうかを決定します。 方向センサーは、デバイスが 3 つすべての物理軸 (x、y、z) を中心に回転する角度を測定します。 方向センサーは、Android 2.2 (API レベル 8) の時点で非推奨となったことに注意してください。|yes、no|
|`hw.sensors.proximity`|**近接センサー** &ndash;エミュレートされたデバイスが近接センサーをサポートするかどうかを決定します。 このセンサーは、デバイスの表示画面を基準にオブジェクトの近接度を測定します。 通常、このセンサーは、ハンドセットがユーザーの耳に当てられているかどうかを判別するために使用されます。|yes、no|
|`hw.sensors.temperature`|**温度センサー** &ndash;エミュレートされたデバイスが温度センサーをサポートするかどうかを決定します。 このセンサー測定温度を摂氏でデバイスの (&deg;C)。|yes、no|
|`hw.touchScreen`|**タッチ スクリーン サポート**&ndash;エミュレートされたデバイスがタッチ スクリーンをサポートするかどうかを決定します。 タッチ スクリーンは、スクリーン上のオブジェクトを直接操作する場合に使用されます。|yes、no|
|`hw.trackBall`|**トラック ボール サポート**&ndash;エミュレートされたデバイスがトラック ボールをサポートするかどうかを決定します。|yes、no|
|`hw.useext4`|**EXT4 ファイル システムのサポート**&ndash;エミュレートされたデバイスがパーティションの Linux EXT4 ファイル システムを使用するかどうかを決定します。 現在、ファイル システムの種類は自動検出されるため、このオプションは非推奨とされており、無視されます。|Ｘ|
|`kernel.newDeviceNaming`|**新しいデバイスの命名カーネル**&ndash;カーネルが新しいデバイスの名前付けスキームを必要とするかどうかを指定するために使用します。 通常、これは Linux 3.10 カーネル以降で使用されます。 場合に設定**autodetect**エミュレーターのカーネルが新しいデバイスの名前付けスキームを必要とするかどうかが自動的に検出します。|autodetect、yes、no|
|`kernel.parameters`|**カーネル パラメーター** &ndash; Linux カーネルのブート パラメーターの文字列を指定します。 既定では、この設定は空白のままになります。||
|`kernel.path`|**カーネル パス** &ndash; Linux カーネルへのパスを指定します。 このパスが指定されていない場合、エミュレーターはカーネル ranchu のエミュレーターのシステム ディレクトリ。||
|`kernel.supportsYaffs2`|**YAFFS2 パーティション サポート**&ndash;カーネルが YAFFS2 であるかどうかを決定します (まだ別 Flash File System 2) パーティション。 通常、これは Linux 3.10 より前のカーネルにのみ適用されます。 場合設定**autodetect**エミュレーターは、カーネルが YAFFS2 ファイル システムをマウントするかどうかを検出して自動的にします。|autodetect、yes、no|
|`skin.name`|**スキン名** &ndash; Android エミュレーター スキンの名前。 スキンは、エミュレーター ディスプレイの視覚および制御要素を定義するファイルのコレクションです。開発コンピューターでの AVD のウィンドウの外観を説明します。 スキンは画面のサイズ、ボタン、全体のデザインを説明しますが、アプリの操作には影響しません。||
|`skin.path`|**スキン パス**&ndash;エミュレーター スキン ファイルを含むディレクトリへのパスが skin.name で指定されたこのディレクトリには、hardware.ini レイアウト ファイルでは、およびスキンの表示要素に対するイメージ ファイルが含まれています。||
|`skin.dynamic`|**スキン動的**&ndash;かどうか、スキンは動的です。 エミュレーターが指定された幅と高さに基づいて特定のサイズのスキンを構築する場合、エミュレーター スキンは動的スキンとなります。|Ｘ|

